<!DOCTYPE html>
<html data-color-mode="light" data-dark-theme="dark" data-light-theme="light" lang="zh-CN">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link href='https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/Primer/21.0.7/primer.css' rel='stylesheet' />
    
    <link rel="icon" href="https://avatars.githubusercontent.com/u/105782835?s=400&u=04c0291bd1e06b01ccad1d53388ed4a8a8894a53&v=4"><script>
        let theme = localStorage.getItem("meek_theme") || "light";
        document.documentElement.setAttribute("data-color-mode", theme);
    </script>
<meta name="description" content="# 前言
内容来源：本文章为阅读《Linux高性能服务器编程》第九章.I/O复用所记录的**部分**笔记。">
<meta property="og:title" content="I/O复用基础">
<meta property="og:description" content="# 前言
内容来源：本文章为阅读《Linux高性能服务器编程》第九章.I/O复用所记录的**部分**笔记。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://waibibab-cs.github.io/post/I-O-fu-yong-ji-chu.html">
<meta property="og:image" content="https://avatars.githubusercontent.com/u/105782835?s=400&u=04c0291bd1e06b01ccad1d53388ed4a8a8894a53&v=4">
<title>I/O复用基础</title>



</head>
<style>
body{box-sizing: border-box;min-width: 200px;max-width: 900px;margin: 20px auto;padding: 45px;font-size: 16px;font-family: sans-serif;line-height: 1.25;}
#header{display:flex;padding-bottom:8px;border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));margin-bottom: 16px;}
#footer {margin-top:64px; text-align: center;font-size: small;}

</style>

<style>
.postTitle{margin: auto 0;font-size:40px;font-weight:bold;}
.title-right{display:flex;margin:auto 0 0 auto;}
.title-right .circle{padding: 14px 16px;margin-right:8px;}
#postBody{border-bottom: 1px solid var(--color-border-default);padding-bottom:36px;}
#postBody hr{height:2px;}
#cmButton{height:48px;margin-top:48px;}
#comments{margin-top:64px;}
.g-emoji{font-size:24px;}
@media (max-width: 600px) {
    body {padding: 8px;}
    .postTitle{font-size:24px;}
}
.copy-feedback {
    display: none;
    position: absolute;
    top: 10px;
    right: 50px;
    color: var(--color-fg-on-emphasis);
    background-color: var(--color-fg-muted);
    border-radius: 3px;
    padding: 5px 8px;
    font-size: 12px;
}
</style>




<body>
    <div id="header">
<h1 class="postTitle">I/O复用基础</h1>
<div class="title-right">
    <a href="https://waibibab-cs.github.io" id="buttonHome" class="btn btn-invisible circle" title="首页">
        <svg class="octicon" width="16" height="16">
            <path id="pathHome" fill-rule="evenodd"></path>
        </svg>
    </a>
    
    <a href="https://github.com/waibibab-cs/waibibab-cs.github.io/issues/14" target="_blank" class="btn btn-invisible circle" title="Issue">
        <svg class="octicon" width="16" height="16">
            <path id="pathIssue" fill-rule="evenodd"></path>
        </svg>
    </a>
    

    <a class="btn btn-invisible circle" onclick="modeSwitch();" title="切换主题">
        <svg class="octicon" width="16" height="16" >
            <path id="themeSwitch" fill-rule="evenodd"></path>
        </svg>
    </a>

</div>
</div>
    <div id="content">
<div class="markdown-body" id="postBody"><h1>前言</h1>
<p>内容来源：本文章为阅读《Linux高性能服务器编程》第九章.I/O复用所记录的<strong>部分</strong>笔记。</p>
<p><strong>I/O 复用技术</strong>是提升程序性能、解决高并发问题的关键手段，它允许单个程序进程同时监听多个文件描述符，从而高效地处理客户端的多连接请求、用户输入与网络交互，以及服务器端的跨协议（TCP/UDP）和多端口服务。尽管 I/O 复用能感知多个事件的就绪状态，但其系统调用本身具有阻塞性，且在处理多个就绪事件时默认是串行执行的；因此，在实际开发中，常需结合多线程或多进程来实现真正的并行并发。在 Linux 环境下，这一技术主要通过 <code class="notranslate">select</code>、<code class="notranslate">poll</code> 以及基于内核事件表的更高性能的 <code class="notranslate">epoll</code> 系统调用来实现。</p>
<h1>1.select系统调用</h1>
<h2>1.1 select API</h2>
<p>select的核心作用：在指定时间内，<strong>同时监听多个文件描述符（如 socket中的listenfd和connfd）的 “可读、可写、异常” 事件</strong> ，实现单进程 / 线程处理多个 I/O 操作。<br>
<a target="_blank" rel="noopener noreferrer nofollow" href="https://raw.githubusercontent.com/waibibab-cs/blog_img/main/cdnimg/20260107110321.png"><img src="https://raw.githubusercontent.com/waibibab-cs/blog_img/main/cdnimg/20260107110321.png" alt="image.png" style="max-width: 100%;"></a><br>
<strong>参数说明</strong>：</p>
<ol>
<li><code class="notranslate">nfds</code>：被监听的文件描述符的<strong>最大值 + 1</strong>（因为文件描述符从 0 开始计数）；</li>
<li><code class="notranslate">readfds/writefds/exceptfds</code>：分别指向 “关注可读、可写、异常事件” 的文件描述符集合（<code class="notranslate">fd_set</code>类型）；<br>
<code class="notranslate">fd_set</code>是<code class="notranslate">select</code>用于管理文件描述符的结构：<br>
<a target="_blank" rel="noopener noreferrer nofollow" href="https://raw.githubusercontent.com/waibibab-cs/blog_img/main/cdnimg/20260107110538.png"><img src="https://raw.githubusercontent.com/waibibab-cs/blog_img/main/cdnimg/20260107110538.png" alt="image.png" style="max-width: 100%;"></a><br>
<code class="notranslate">fd_set</code>结构体仅包含一个整型数组，该数组每个元素的每一位标记一个文件描述符，其所能容纳的文件描述符数量由FD_SETSIZE指定，这就限制了select能同时处理的文件描述符的总量，例如：假设<code class="notranslate">__fd_mask</code>是 8 字节→64 位，<code class="notranslate">FD_SETSIZE=1024</code>，我们想要存储fd=3和fd=70两个文件描述符，<code class="notranslate">fd_set</code>的内部状态为：<br>
<a target="_blank" rel="noopener noreferrer nofollow" href="https://raw.githubusercontent.com/waibibab-cs/blog_img/main/cdnimg/20260107112241.png"><img src="https://raw.githubusercontent.com/waibibab-cs/blog_img/main/cdnimg/20260107112241.png" alt="image.png" style="max-width: 100%;"></a><br>
<a target="_blank" rel="noopener noreferrer nofollow" href="https://raw.githubusercontent.com/waibibab-cs/blog_img/main/cdnimg/20260107111013.png"><img src="https://raw.githubusercontent.com/waibibab-cs/blog_img/main/cdnimg/20260107111013.png" alt="image.png" style="max-width: 100%;"></a><br>
<strong>举一个例子</strong>：</li>
</ol>
<pre lang="c" class="notranslate"><code class="notranslate">#include &lt;stdio.h&gt;
#include &lt;sys/select.h&gt;

int main() {
    // 1. 定义一个fd_set集合
    fd_set my_fd_set;

    // 2. 清空集合（必须先清空，否则初始值是随机的）
    FD_ZERO(&amp;my_fd_set);

    // 3. 装载（添加）fd到集合中
    int fd1 = 3;  // 假设是listenfd
    int fd2 = 5;  // 假设是connfd
    FD_SET(fd1, &amp;my_fd_set);
    FD_SET(fd2, &amp;my_fd_set);

    // 4. 判断某个fd是否在集合中
    if (FD_ISSET(fd1, &amp;my_fd_set)) {
        printf("fd=%d 已被装载到集合中\n", fd1);
    }
    if (FD_ISSET(fd2, &amp;my_fd_set)) {
        printf("fd=%d 已被装载到集合中\n", fd2);
    }
    if (!FD_ISSET(4, &amp;my_fd_set)) {
        printf("fd=4 不在集合中\n");
    }

    // 5. 从集合中移除fd
    FD_CLR(fd2, &amp;my_fd_set);
    if (!FD_ISSET(fd2, &amp;my_fd_set)) {
        printf("fd=%d 已从集合中移除\n", fd2);
    }

    return 0;
}
</code></pre>
<ol start="3">
<li><code class="notranslate">timeout</code>：设置select函数的超时时间<br>
<a target="_blank" rel="noopener noreferrer nofollow" href="https://raw.githubusercontent.com/waibibab-cs/blog_img/main/cdnimg/20260107112937.png"><img src="https://raw.githubusercontent.com/waibibab-cs/blog_img/main/cdnimg/20260107112937.png" alt="image.png" style="max-width: 100%;"></a>
<ul>
<li>timeout的成员变量均设<code class="notranslate">0</code>：立即返回；</li>
<li>timeout设为<code class="notranslate">NULL</code>：永久阻塞，直到有某个文件描述符就绪。<br>
select成功时返回就绪文件描述符的总数，如果在超过时间内没有任何文件描述符就绪，select返回0，select失败会返回-1</li>
</ul>
</li>
</ol>
<h2>1.2 文件描述符就绪条件</h2>
<p>一、socket “可读” 的条件（<code class="notranslate">readfds</code>就绪）<br>
当满足以下任意一种情况时，<code class="notranslate">select</code>会标记该 socket 为 “可读”：</p>
<ol>
<li><strong>接收缓存区有数据</strong>：<br>
socket 内核接收缓存区的字节数 ≥ 低水位标记<code class="notranslate">SO_RCVLOWAT</code>（默认通常是 1 字节），此时调用<code class="notranslate">read/recv</code>可以无阻塞地读到数据（返回字节数 &gt; 0）。</li>
<li><strong>对方关闭连接</strong>：<br>
通信对方关闭连接（发了 FIN 包），此时调用<code class="notranslate">read/recv</code>会返回 0（表示连接已关闭）。</li>
<li><strong>监听 socket 有新连接</strong>：<br>
<code class="notranslate">listenfd</code>对应的监听 socket 上有新客户端完成三次握手，此时调用<code class="notranslate">accept</code>可以取出新连接。</li>
<li><strong>socket 有未处理错误</strong>：<br>
socket 发生错误（如连接失败），此时可通过<code class="notranslate">getsockopt</code>读取并清除错误。</li>
</ol>
<p>二、socket “可写” 的条件（<code class="notranslate">writefds</code>就绪）<br>
当满足以下任意一种情况时，<code class="notranslate">select</code>会标记该 socket 为 “可写”：</p>
<ol>
<li><strong>发送缓存区有空间</strong>：<br>
socket 内核发送缓存区的可用字节数 ≥ 低水位标记<code class="notranslate">SO_SNDLOWAT</code>（默认通常是 1 字节），此时调用<code class="notranslate">write/send</code>可以无阻塞地发送数据（返回字节数 &gt; 0）。</li>
<li><strong>写操作被关闭</strong>：<br>
socket 的写端被关闭（如调用<code class="notranslate">shutdown(sockfd, SHUT_WR)</code>），此时执行写操作会触发<code class="notranslate">SIGPIPE</code>信号。</li>
<li><strong>非阻塞 connect 完成</strong>：<br>
用非阻塞<code class="notranslate">connect</code>发起的连接，无论成功或失败（超时），都会标记 socket 为 “可写”。</li>
<li><strong>socket 有未处理错误</strong>：<br>
同 “可读” 的第 4 条，socket 发生错误时也会标记为 “可写”。</li>
</ol>
<p>三、socket “异常” 的条件（<code class="notranslate">exceptfds</code>就绪）<br>
<code class="notranslate">select</code>中 socket 的异常事件<strong>只有一种场景</strong>：</p>
<ul>
<li>socket 接收到<strong>带外数据（OOB）</strong>（即对方用<code class="notranslate">send(..., MSG_OOB)</code>发送的紧急数据）。</li>
</ul>
<h2>1.3 处理带外数据</h2>
<p>一、核心逻辑：区分普通数据与带外数据的就绪状态<br>
<code class="notranslate">select</code>中，socket 接收<strong>普通数据</strong>会触发 “可读事件（<code class="notranslate">readfds</code>）”，接收 <strong>带外数据（OOB）</strong> 会触发 “异常事件（<code class="notranslate">exceptfds</code>）”—— 通过同时监听这两个事件集合，就能分别处理两类数据。<br>
二、代码实现步骤</p>
<ol>
<li><strong>初始化监听集合</strong>：<br>
定义<code class="notranslate">read_fds</code>（监听普通数据）和<code class="notranslate">except_fds</code>（监听带外数据），并通过<code class="notranslate">FD_ZERO</code>清空集合。</li>
<li><strong>循环监听事件</strong>：
<ul>
<li>每次<code class="notranslate">select</code>前，都要重新用<code class="notranslate">FD_SET</code>将<code class="notranslate">connfd</code>加入<code class="notranslate">read_fds</code>和<code class="notranslate">except_fds</code>（因为<code class="notranslate">select</code>会修改集合，需重新设置）；</li>
<li>调用<code class="notranslate">select</code>阻塞等待事件（仅监听<code class="notranslate">read_fds</code>和<code class="notranslate">except_fds</code>）。</li>
</ul>
</li>
<li><strong>处理事件</strong>：
<ul>
<li>若<code class="notranslate">connfd</code>在<code class="notranslate">read_fds</code>中：用普通<code class="notranslate">recv(..., 0)</code>读取<strong>普通数据</strong>；</li>
<li>若<code class="notranslate">connfd</code>在<code class="notranslate">except_fds</code>中：用<code class="notranslate">recv(..., MSG_OOB)</code>读取<strong>带外数据</strong>。<br>
三、关键细节</li>
</ul>
</li>
</ol>
<ul>
<li><strong>每次<code class="notranslate">select</code>前需重新设置集合</strong>：因为<code class="notranslate">select</code>返回后会修改<code class="notranslate">fd_set</code>（只保留就绪的 fd），所以下次调用前必须重新将<code class="notranslate">connfd</code>加入集合；</li>
<li><strong>带外数据的读取标志</strong>：必须用<code class="notranslate">MSG_OOB</code>标志调用<code class="notranslate">recv</code>，才能正确读取带外数据；</li>
<li><strong>异常事件的唯一性</strong>：<code class="notranslate">select</code>中 socket 的异常事件仅对应 “带外数据到达”，因此<code class="notranslate">except_fds</code>就绪时直接处理带外数据即可。<br>
<a target="_blank" rel="noopener noreferrer nofollow" href="https://raw.githubusercontent.com/waibibab-cs/blog_img/main/cdnimg/20260107115223.png"><img src="https://raw.githubusercontent.com/waibibab-cs/blog_img/main/cdnimg/20260107115223.png" alt="image.png" style="max-width: 100%;"></a></li>
</ul>
<h1>2.poll系统调用</h1>
<p><code class="notranslate">poll</code> 与 <code class="notranslate">select</code> 类似，用于在指定时间内轮询一定数量的文件描述符（fd），以测试其中是否有就绪事件（如可读、可写、异常等）。<br>
<a target="_blank" rel="noopener noreferrer nofollow" href="https://raw.githubusercontent.com/waibibab-cs/blog_img/main/cdnimg/20260115210255.png"><img src="https://raw.githubusercontent.com/waibibab-cs/blog_img/main/cdnimg/20260115210255.png" alt="image.png" style="max-width: 100%;"></a></p>
<ul>
<li><strong><code class="notranslate">fds</code></strong> ：指向一个 <code class="notranslate">pollfd</code> 结构体数组的指针。</li>
<li><strong><code class="notranslate">nfds</code></strong> ：数组中元素的个数。</li>
<li><strong><code class="notranslate">timeout</code></strong> ：超时时间，单位是<strong>毫秒</strong>。</li>
</ul>
<p>核心数据结构：<code class="notranslate">struct pollfd</code><br>
这是 <code class="notranslate">poll</code> 与 <code class="notranslate">select</code> 最显著的区别。它通过结构体而非位图（bitmask）来管理事件，更加清晰直观。<br>
<a target="_blank" rel="noopener noreferrer nofollow" href="https://raw.githubusercontent.com/waibibab-cs/blog_img/main/cdnimg/20260115210448.png"><img src="https://raw.githubusercontent.com/waibibab-cs/blog_img/main/cdnimg/20260115210448.png" alt="image.png" style="max-width: 100%;"></a></p>
<ul>
<li><strong><code class="notranslate">events</code>（输入）</strong> ：用户设置的感兴趣的事件。</li>
<li><strong><code class="notranslate">revents</code>（输出）</strong> ：内核修改，返回实际发生的事件。由于输入和输出分离，<strong>不需要像 <code class="notranslate">select</code> 那样每次调用前重置</strong>。</li>
</ul>
<p>常用事件类型（<code class="notranslate">poll</code> 事件表）</p>
<ul>
<li><strong><code class="notranslate">POLLIN</code></strong> ：数据可读（包括普通数据和优先级数据）。</li>
<li><strong><code class="notranslate">POLLOUT</code></strong> ：数据可写。</li>
<li><strong><code class="notranslate">POLLRDHUP</code></strong> （重点）：自 Linux 2.6.17 起引入，用于<strong>检测 TCP 连接被对方关闭</strong>或对方关闭了写操作。使用时需定义 <code class="notranslate">_GNU_SOURCE</code>。</li>
<li><strong><code class="notranslate">POLLERR</code></strong> ：发生错误。</li>
<li><strong><code class="notranslate">POLLHUP</code></strong> ：挂起（如管道写端关闭，读端将收到此事件）。</li>
<li><strong><code class="notranslate">POLLNVAL</code></strong> ：文件描述符没有打开。</li>
</ul>
<p>代码案例：</p>
<pre lang="cpp" class="notranslate"><code class="notranslate">struct pollfd fds[2];
// 监听socket的可读事件（比如是否有客户端连接、是否有数据发送过来）
fds[0].fd = sockfd;
fds[0].events = POLLIN;

// 监听文件描述符的可写+错误事件
fds[1].fd = filefd;
fds[1].events = POLLOUT | POLLERR;

int ret = poll(fds, 2, 5000); // 监听2个fd，超时5秒
if(ret &gt; 0){
    // 检查第一个fd是否触发了可读事件
    if(fds[0].revents &amp; POLLIN){
        // 执行socket读操作，比如accept或者recv
        handle_socket_read(fds[0].fd);
    }
    // 检查第二个fd是否触发了可写事件
    if(fds[1].revents &amp; POLLOUT){
        // 执行文件写操作
        handle_file_write(fds[1].fd);
    }
    // 检查是否出现错误
    if(fds[1].revents &amp; POLLERR){
        // 处理错误逻辑
        handle_error(fds[1].fd);
    }
}
</code></pre>
<h1>3.epoll系统调用</h1>
<h2>内核事件表</h2>
<p>一、 epoll 概述 (epoll Overview)</p>
<ul>
<li><strong>特性</strong>：Linux 特有的 I/O 复用函数。</li>
<li><strong>核心差异</strong>：与 <code class="notranslate">select</code> 和 <code class="notranslate">poll</code> 不同，<code class="notranslate">epoll</code> 使用<strong>一组函数</strong>来完成任务，而不是单个函数。</li>
<li><strong>内核事件表</strong>：<code class="notranslate">epoll</code> 在内核中维护一个事件表，记录用户关心的文件描述符（fd）及其事件。
<ul>
<li><strong>优势</strong>：无需像 <code class="notranslate">select/poll</code> 那样每次调用都重复传入文件描述符集或事件集，大幅减少了数据拷贝的开销。</li>
</ul>
</li>
<li><strong>句柄</strong>：<code class="notranslate">epoll</code> 需要一个额外的文件描述符来唯一标识内核中的这个事件表。</li>
</ul>
<p>二、 核心 API：epoll_create<br>
用于创建一个内核事件表。</p>
<pre class="notranslate"><code class="notranslate">#include &lt;sys/epoll.h&gt;
int epoll_create(int size);
</code></pre>
<ul>
<li><strong>参数 <code class="notranslate">size</code></strong> ：现在不起实际作用，仅给内核一个提示，建议事件表的大小。</li>
<li><strong>返回值</strong>：成功时返回一个文件描述符，作为后续所有 epoll 系统调用的第一个参数（用于指定访问的内核事件表）。</li>
</ul>
<p>三、 核心 API：epoll_ctl<br>
用于操作（添加、修改、删除）内核事件表中的事件。</p>
<pre class="notranslate"><code class="notranslate">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
</code></pre>
<ol>
<li>操作类型 (<code class="notranslate">op</code>)</li>
</ol>
<ul>
<li><strong><code class="notranslate">EPOLL_CTL_ADD</code></strong> ：往事件表中注册 <code class="notranslate">fd</code> 上的事件。</li>
<li><strong><code class="notranslate">EPOLL_CTL_MOD</code></strong> ：修改 <code class="notranslate">fd</code> 上已注册的事件。</li>
<li><strong><code class="notranslate">EPOLL_CTL_DEL</code></strong> ：从事件表中删除 <code class="notranslate">fd</code> 上的注册事件。</li>
</ul>
<ol>
<li>重要结构体：<code class="notranslate">struct epoll_event</code></li>
</ol>
<pre class="notranslate"><code class="notranslate">struct epoll_event {
    __uint32_t events;    /* epoll 事件类型 */
    epoll_data_t data;    /* 用户数据 */
};
</code></pre>
<ul>
<li><strong><code class="notranslate">events</code> 成员</strong>：
<ul>
<li>描述事件类型（如 <code class="notranslate">EPOLLIN</code> 表示可读）。</li>
<li><strong>关键类型</strong>：<code class="notranslate">EPOLLET</code>（边缘触发）和 <code class="notranslate">EPOLLONESHOT</code>（保证同一fd只被一个线程处理）。</li>
</ul>
</li>
<li><strong><code class="notranslate">data</code> 成员</strong>：类型为 <code class="notranslate">epoll_data_t</code>（联合体），用于存储用户数据。</li>
</ul>
<ol start="3">
<li>用户数据联合体：<code class="notranslate">epoll_data_t</code></li>
</ol>
<pre class="notranslate"><code class="notranslate">typedef union epoll_data {
    void* ptr;
    int fd;
    uint32_t u32;
    uint64_t u64;
} epoll_data_t;
</code></pre>
<ul>
<li><strong>使用注意</strong>：
<ul>
<li>它是<strong>联合体</strong>，不能同时使用 <code class="notranslate">ptr</code> 和 <code class="notranslate">fd</code>。</li>
<li><strong>常用方式</strong>：通常使用 <code class="notranslate">fd</code> 指定事件所属的目标文件描述符；若需要关联更多用户数据，则使用 <code class="notranslate">ptr</code>（并在数据结构中包含 <code class="notranslate">fd</code>）。<br>
四、 返回值总结</li>
</ul>
</li>
<li><strong><code class="notranslate">epoll_ctl</code></strong> ：成功返回 <code class="notranslate">0</code>，失败返回 <code class="notranslate">-1</code> 并设置 <code class="notranslate">errno</code>。</li>
</ul>
<h2>epoll_wait函数</h2>
<p>一、 epoll_wait 函数原型<br>
<code class="notranslate">epoll_wait</code> 是 epoll 系列系统调用的核心接口，用于在一段超时时间内等待一组文件描述符上的事件。</p>
<pre class="notranslate"><code class="notranslate">#include &lt;sys/epoll.h&gt;
int epoll_wait(int epfd, struct epoll_event* events, int maxevents, int timeout);
</code></pre>
<ol>
<li>参数详解 (从后往前)</li>
</ol>
<ul>
<li><strong><code class="notranslate">timeout</code></strong> ：指定等待的超时时间（毫秒）。含义与 <code class="notranslate">poll</code> 的 timeout 参数相同。</li>
<li><strong><code class="notranslate">maxevents</code></strong> ：指定最多监听多少个事件，必须大于 0。</li>
<li><strong><code class="notranslate">events</code> (核心)</strong> ：
<ul>
<li>这是一个<strong>输出型参数</strong>。</li>
<li>如果检测到就绪事件，内核会将所有就绪事件从内核事件表复制到这个数组中。</li>
</ul>
</li>
<li><strong><code class="notranslate">epfd</code></strong> ：由 <code class="notranslate">epoll_create</code> 创建的 epoll 文件描述符，指定要访问的内核事件表。</li>
</ul>
<ol>
<li>返回值</li>
</ol>
<ul>
<li><strong>成功</strong>：返回就绪的文件描述符个数。</li>
<li><strong>失败</strong>：返回 <code class="notranslate">-1</code> 并设置 <code class="notranslate">errno</code>。<br>
二、 epoll_wait 的设计优势<br>
与 <code class="notranslate">select</code> 和 <code class="notranslate">poll</code> 相比，<code class="notranslate">epoll_wait</code> 在处理就绪事件时效率极高：</li>
<li><strong>不仅是输入，更是输出</strong>：<code class="notranslate">select/poll</code> 传入的数组既包含要监听的事件，又在返回时被覆盖为就绪事件。而 <code class="notranslate">epoll</code> 的 <code class="notranslate">events</code> 数组<strong>只用于输出</strong>检测到的就绪事件。</li>
<li><strong>内核到用户的拷贝</strong>：无需像 <code class="notranslate">select/poll</code> 那样每次调用都重新传入整个事件集合，只需从内核取出已就绪的部分。<br>
<a target="_blank" rel="noopener noreferrer nofollow" href="https://raw.githubusercontent.com/waibibab-cs/blog_img/main/cdnimg/20260119173739.png"><img src="https://raw.githubusercontent.com/waibibab-cs/blog_img/main/cdnimg/20260119173739.png" alt="image.png" style="max-width: 100%;"></a></li>
</ul>
<h2>LT和ET模式</h2>
<p>一、 基本概念<br>
<code class="notranslate">epoll</code> 对文件描述符的操作有两种工作模式，决定了内核何时以及如何通知应用程序事件。</p>
<ol>
<li>LT 模式 (Level Trigger, 电平触发)</li>
</ol>
<ul>
<li><strong>地位</strong>：默认工作模式。</li>
<li><strong>机制</strong>：类似于一个高效率的 <code class="notranslate">poll</code>。只要文件描述符上有事件（如读缓存中有数据），每次调用 <code class="notranslate">epoll_wait</code> 都会触发通知。</li>
<li><strong>特点</strong>：即使应用程序在得到通知后不立即处理，下次调用 <code class="notranslate">epoll_wait</code> 时仍会再次通知，直到该事件被处理完。</li>
</ul>
<ol start="2">
<li>ET 模式 (Edge Trigger, 边沿触发)</li>
</ol>
<ul>
<li><strong>地位</strong>：<code class="notranslate">epoll</code> 的高效工作模式。</li>
<li><strong>启用</strong>：在注册事件时通过位或 <code class="notranslate">EPOLLET</code> 宏开启。</li>
<li><strong>机制</strong>：内核只在状态发生变化时通知一次（例如：数据从无到有）。</li>
<li><strong>特点</strong>：应用程序收到通知后<strong>必须立即处理</strong>该事件。因为后续的 <code class="notranslate">epoll_wait</code> 调用将不再向应用程序发送关于该事件的重复通知。<br>
二、 核心差异对比</li>
</ul>
<markdown-accessiblity-table><table role="table">
<thead>
<tr>
<th>特性</th>
<th>LT 模式 (Level Trigger)</th>
<th>ET 模式 (Edge Trigger)</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>通知频率</strong></td>
<td>只要满足条件就会重复触发</td>
<td>仅在状态改变时触发一次</td>
</tr>
<tr>
<td><strong>编程难度</strong></td>
<td>较低，允许只处理部分数据</td>
<td>较高，必须一次性完成处理</td>
</tr>
<tr>
<td><strong>性能效率</strong></td>
<td>性能不错，但系统调用次数可能较多</td>
<td>极高，大幅降低了重复触发次数</td>
</tr>
<tr>
<td><strong>I/O 模式</strong></td>
<td>阻塞/非阻塞均可</td>
<td><strong>必须使用非阻塞 I/O</strong></td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<p>三、 编程实现要点 (基于代码清单 9-3)</p>
<ol>
<li>非阻塞设置 (<code class="notranslate">setnonblocking</code>)<br>
在 ET 模式下，必须通过 <code class="notranslate">fcntl</code> 将文件描述符设置为非阻塞模式，否则读或写操作将会因为没有后续的事件而一直处于阻塞状态</li>
</ol>
<ul>
<li><strong>对于阻塞 I/O</strong>：如果你用 <code class="notranslate">epoll</code> 监听 10000 个 <code class="notranslate">sockfd</code>，但你使用了阻塞 I/O。当你去 <code class="notranslate">read</code> 其中一个连接时，万一由于某种原因数据没读全，导致程序被阻塞在该 fd 上，另外 9999 个连接就算有新消息，你也处理不了了。</li>
<li><strong>对于非阻塞 I/O</strong>：通过 <code class="notranslate">fcntl</code> 设置了 <code class="notranslate">O_NONBLOCK</code> 后，<code class="notranslate">epoll_wait</code> 告诉你哪个 fd 有数据，你才去读。即使你读得太勤（读到了缓冲区为空），也会因为非阻塞特性立即返回，让你能赶紧回到 <code class="notranslate">epoll_wait</code> 去看护其他 9999 个“孩子”</li>
</ul>
<pre class="notranslate"><code class="notranslate">int old_option = fcntl(fd, F_GETFL);
int new_option = old_option | O_NONBLOCK;
fcntl(fd, F_SETFL, new_option);
</code></pre>
<ol start="2">
<li>ET 模式下的读取逻辑<br>
由于 ET 模式只通知一次，如果读缓存中数据很多，一次 <code class="notranslate">recv</code> 读不完，<code class="notranslate">epoll_wait</code> 就不会再报了。</li>
</ol>
<ul>
<li><strong>解决方案</strong>：必须配合 <strong><code class="notranslate">while(1)</code> 循环</strong> 读取，直到数据全部读出。</li>
<li><strong>退出循环条件</strong>：当 <code class="notranslate">recv</code> 返回 <code class="notranslate">-1</code> 且 <code class="notranslate">errno</code> 为 <code class="notranslate">EAGAIN</code> 或 <code class="notranslate">EWOULDBLOCK</code> 时，说明缓冲区已空。</li>
</ul>
<ol start="2">
<li>LT 模式下的读取逻辑</li>
</ol>
<ul>
<li>比较简单，每次触发 <code class="notranslate">EPOLLIN</code> 后调用一次 <code class="notranslate">recv</code> 即可。如果还有剩余数据，内核会在下一次循环中再次通知。</li>
</ul>
<h2>EPOLLONESHOT事件</h2>
<p>一、 I/O 模式：阻塞 vs 非阻塞</p>
<ul>
<li><strong>阻塞 I/O (Blocking)</strong> ：调用 <code class="notranslate">recv</code> 时若无数据，线程挂起死等。
<ul>
<li>缺点：单线程只能处理一个连接，并发能力差。</li>
</ul>
</li>
<li><strong>非阻塞 I/O (Non-blocking)</strong> ：调用 <code class="notranslate">recv</code> 时若无数据，立即返回 <code class="notranslate">-1</code> 并设置 <code class="notranslate">errno = EAGAIN</code>。
<ul>
<li>优点：配合多路复用（epoll）可实现单线程管理万级连接。<br>
二、 触发模式：LT vs ET</li>
</ul>
</li>
<li><strong>LT (水平触发 - Level Triggered)</strong> ：
<ul>
<li><strong>逻辑</strong>：只要缓冲区有数据，<code class="notranslate">epoll_wait</code> 就会不断通知。</li>
<li><strong>特点</strong>：编程简单，安全可靠；但内核通知次数多，开销大。</li>
</ul>
</li>
<li><strong>ET (边沿触发 - Edge Triggered)</strong> ：
<ul>
<li><strong>逻辑</strong>：只有状态发生变化（数据从无到有、新数据到达）时才通知一次。</li>
<li><strong>特点</strong>：效率极高，减少内核通知次数。</li>
<li><strong>硬性要求</strong>：必须配合<strong>非阻塞 I/O</strong>，且必须使用 <code class="notranslate">while</code> 循环读完所有数据（读到 <code class="notranslate">EAGAIN</code> 为止）。<br>
三、 核心难点：为什么 ET 模式下仍会触发多次？</li>
</ul>
</li>
<li><strong>现象</strong>：在 ET 模式下，如果线程正在处理旧数据时突然有<strong>新数据</strong>到达，内核会将其判定为一个新的“边沿”，导致 <code class="notranslate">epoll_wait</code> 再次被触发。</li>
<li><strong>风险</strong>：在多线程开发中，这会导致<strong>不同线程同时操作同一个 socket</strong>，引发竞态条件（Race Condition），导致数据读写错乱。<br>
四、 解决方案：EPOLLONESHOT 事件</li>
<li><strong>定义</strong>：一种特殊的 epoll 事件标志。</li>
<li><strong>作用机制</strong>：
<ol>
<li><strong>触发一次</strong>：内核触发该 fd 的事件后，立即将其从内核事件表中“禁用”（不再监控）。</li>
<li><strong>独占性</strong>：无论该 socket 是否有新数据，<code class="notranslate">epoll_wait</code> 均不再通知，确保同一时刻<strong>只有一个线程</strong>在处理该 socket。</li>
<li><strong>人工重置</strong>：当工作线程处理完该 socket 的逻辑后，必须手动调用 <code class="notranslate">epoll_ctl</code> 使用 <code class="notranslate">EPOLL_CTL_MOD</code> 命令重置（重新激活）该事件。</li>
</ol>
</li>
<li><strong>注意</strong>：<code class="notranslate">listenfd</code>（监听 socket）通常<strong>不设置</strong> <code class="notranslate">EPOLLONESHOT</code>，否则只能接收到一个客户端连接。<br>
五、 编程最佳实践（代码逻辑模型）</li>
</ul>
<ol>
<li><strong>设置非阻塞</strong>：<code class="notranslate">fcntl(fd, F_SETFL, O_NONBLOCK)</code>。</li>
<li><strong>注册事件</strong>：<code class="notranslate">event.events = EPOLLIN | EPOLLET | EPOLLONESHOT</code>。</li>
<li><strong>循环读取</strong>：工作线程接收到通知后，用 <code class="notranslate">while</code> 循环 <code class="notranslate">recv</code>。</li>
<li><strong>识别结束</strong>：
<ul>
<li><code class="notranslate">ret &gt; 0</code>：继续读。</li>
<li><code class="notranslate">ret == 0</code>：对端关闭连接，执行 <code class="notranslate">close(fd)</code>。</li>
<li><code class="notranslate">ret &lt; 0 &amp;&amp; errno == EAGAIN</code>：读完了，调用 <code class="notranslate">reset_oneshot()</code> 恢复监控。</li>
</ul>
</li>
</ol>
<h1>4.三组I/O复用函数的比较</h1>
<p>一、 I/O 复用技术大比拼 (select, poll, epoll)</p>
<markdown-accessiblity-table><table role="table">
<thead>
<tr>
<th>特性</th>
<th>select</th>
<th>poll</th>
<th>epoll</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>数据结构</strong></td>
<td>3个 fd_set（位图）</td>
<td>pollfd 结构体数组</td>
<td>内核事件表</td>
</tr>
<tr>
<td><strong>索引复杂度</strong></td>
<td>O(n)：需遍历整个 fd 集合</td>
<td>O(n)：需遍历整个 fd 集合</td>
<td><strong>O(1)</strong> ：直接返回就绪事件</td>
</tr>
<tr>
<td><strong>最大连接数</strong></td>
<td>有限制（通常 1024）</td>
<td>无限制（65535+）</td>
<td>无限制（65535+）</td>
</tr>
<tr>
<td><strong>内核实现</strong></td>
<td><strong>轮询</strong>方式扫描所有 fd</td>
<td><strong>轮询</strong>方式扫描所有 fd</td>
<td><strong>回调</strong>方式（Callback）</td>
</tr>
<tr>
<td><strong>工作模式</strong></td>
<td>仅支持 LT (水平触发)</td>
<td>仅支持 LT (水平触发)</td>
<td><strong>支持 ET (边沿触发) 和 LT</strong></td>
</tr>
<tr>
<td><strong>参数传递</strong></td>
<td>每次调用需重置 fd 集合</td>
<td>无需重置事件参数</td>
<td>无需重复传入事件，仅需添加/修改</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<p>二、 epoll 的进阶神器：<code class="notranslate">EPOLLONESHOT</code></p>
<ol>
<li>核心背景：多线程并发冲突<br>
在多线程环境下，即便使用 ET（边沿触发）模式，如果一个线程在处理某个 Socket 期间又有新数据到达，内核可能会唤醒另一个线程来处理同一个 Socket。</li>
</ol>
<ul>
<li><strong>后果</strong>：导致数据交织、状态混乱、竞态条件。<br>
2. <code class="notranslate">EPOLLONESHOT</code> 的原理<br>
一旦某个文件描述符（fd）上注册了该事件：</li>
<li><strong>一次性触发</strong>：内核触发读、写或异常事件中的任意一个后，会立即**“禁用”** 该 fd 的所有后续通知。</li>
<li><strong>状态冻结</strong>：除非程序员手动重置，否则该 fd 永远不会再通过 <code class="notranslate">epoll_wait</code> 返回。</li>
</ul>
<ol>
<li>核心机制：重置（Reset）</li>
</ol>
<ul>
<li><strong>目的</strong>：通知内核该 fd 已经处理完毕，可以重新开始监控。</li>
<li><strong>操作方法</strong>：调用 <code class="notranslate">epoll_ctl</code> 并指定 <code class="notranslate">EPOLL_CTL_MOD</code> 命令。</li>
<li><strong>本质逻辑</strong>：
<ul>
<li>即便修改后的事件参数与之前完全一样，调用 <code class="notranslate">MOD</code> 也会<strong>清除内核内部的禁用标记</strong>。</li>
<li>这相当于给“保险丝”推闸复位。<br>
三、 典型并发处理流（工作线程模式）</li>
</ul>
</li>
</ul>
<ol>
<li><strong>注册</strong>：主线程将 Socket 注册为 <code class="notranslate">EPOLLIN | EPOLLET | EPOLLONESHOT</code>。</li>
<li><strong>分发</strong>：<code class="notranslate">epoll_wait</code> 收到通知，唤醒一个工作线程处理该 Socket。</li>
<li><strong>处理</strong>：
<ul>
<li>由于 <code class="notranslate">EPOLLONESHOT</code>，其他线程绝不会抢占该 Socket。</li>
<li>工作线程循环读取数据直到返回 <code class="notranslate">EAGAIN</code>。</li>
</ul>
</li>
<li><strong>复位</strong>：处理完成后，工作线程调用 <code class="notranslate">reset_oneshot</code>（即 <code class="notranslate">epoll_ctl(MOD)</code>）。</li>
<li><strong>循环</strong>：内核重新监控，等待下一次事件。<br>
四、 关键结论与建议</li>
</ol>
<ul>
<li><strong>性能权衡</strong>：<code class="notranslate">epoll</code> 在连接数多、但活跃连接少的情况下表现最佳；如果连接极少且极其活跃，<code class="notranslate">select/poll</code> 性能未必更差。</li>
<li><strong>安全防范</strong>：凡是<strong>多线程</strong>操作同一个 epoll 实例中的相同 fd，<strong>必须</strong>加 <code class="notranslate">EPOLLONESHOT</code>，否则无法保证线程安全。</li>
<li><strong>细节提醒</strong>：注册了 <code class="notranslate">EPOLLONESHOT</code> 的 fd，一旦处理完业务逻辑，千万记得 <code class="notranslate">MOD</code> 回去，否则该 Socket 会变成“死连接”（永不触发）。</li>
</ul></div>
<div style="font-size:small;margin-top:8px;float:right;"></div>

<button class="btn btn-block" type="button" onclick="openComments()" id="cmButton">评论</button>
<div class="comments" id="comments"></div>

</div>
    <div id="footer"><div id="footer1">Copyright © <span id="copyrightYear"></span> <a href="https://waibibab-cs.github.io">waibibab's blog</a></div>
<div id="footer2">
    <span id="runday"></span><span>Powered by <a href="https://meekdai.com/Gmeek.html" target="_blank">Gmeek</a></span>
</div>

<script>
var now=new Date();
document.getElementById("copyrightYear").innerHTML=now.getFullYear();

if(""!=""){
    var startSite=new Date("");
    var diff=now.getTime()-startSite.getTime();
    var diffDay=Math.floor(diff/(1000*60*60*24));
    document.getElementById("runday").innerHTML="网站运行"+diffDay+"天"+" • ";
}
</script></div>
</body>
<script>
var IconList={'sun': 'M8 10.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5zM8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0V.75A.75.75 0 018 0zm0 13a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 018 13zM2.343 2.343a.75.75 0 011.061 0l1.06 1.061a.75.75 0 01-1.06 1.06l-1.06-1.06a.75.75 0 010-1.06zm9.193 9.193a.75.75 0 011.06 0l1.061 1.06a.75.75 0 01-1.06 1.061l-1.061-1.06a.75.75 0 010-1.061zM16 8a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 0116 8zM3 8a.75.75 0 01-.75.75H.75a.75.75 0 010-1.5h1.5A.75.75 0 013 8zm10.657-5.657a.75.75 0 010 1.061l-1.061 1.06a.75.75 0 11-1.06-1.06l1.06-1.06a.75.75 0 011.06 0zm-9.193 9.193a.75.75 0 010 1.06l-1.06 1.061a.75.75 0 11-1.061-1.06l1.06-1.061a.75.75 0 011.061 0z', 'moon': 'M9.598 1.591a.75.75 0 01.785-.175 7 7 0 11-8.967 8.967.75.75 0 01.961-.96 5.5 5.5 0 007.046-7.046.75.75 0 01.175-.786zm1.616 1.945a7 7 0 01-7.678 7.678 5.5 5.5 0 107.678-7.678z', 'sync': 'M1.705 8.005a.75.75 0 0 1 .834.656 5.5 5.5 0 0 0 9.592 2.97l-1.204-1.204a.25.25 0 0 1 .177-.427h3.646a.25.25 0 0 1 .25.25v3.646a.25.25 0 0 1-.427.177l-1.38-1.38A7.002 7.002 0 0 1 1.05 8.84a.75.75 0 0 1 .656-.834ZM8 2.5a5.487 5.487 0 0 0-4.131 1.869l1.204 1.204A.25.25 0 0 1 4.896 6H1.25A.25.25 0 0 1 1 5.75V2.104a.25.25 0 0 1 .427-.177l1.38 1.38A7.002 7.002 0 0 1 14.95 7.16a.75.75 0 0 1-1.49.178A5.5 5.5 0 0 0 8 2.5Z', 'home': 'M6.906.664a1.749 1.749 0 0 1 2.187 0l5.25 4.2c.415.332.657.835.657 1.367v7.019A1.75 1.75 0 0 1 13.25 15h-3.5a.75.75 0 0 1-.75-.75V9H7v5.25a.75.75 0 0 1-.75.75h-3.5A1.75 1.75 0 0 1 1 13.25V6.23c0-.531.242-1.034.657-1.366l5.25-4.2Zm1.25 1.171a.25.25 0 0 0-.312 0l-5.25 4.2a.25.25 0 0 0-.094.196v7.019c0 .138.112.25.25.25H5.5V8.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v5.25h2.75a.25.25 0 0 0 .25-.25V6.23a.25.25 0 0 0-.094-.195Z', 'github': 'M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z', 'copy': 'M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z', 'check': 'M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z'};
var utterancesLoad=0;

let themeSettings={
    "dark": ["dark","moon","#00f0ff","dark-blue"],
    "light": ["light","sun","#ff5000","github-light"],
    "auto": ["auto","sync","","preferred-color-scheme"]
};
function changeTheme(mode, icon, color, utheme){
    document.documentElement.setAttribute("data-color-mode",mode);
    document.getElementById("themeSwitch").setAttribute("d",value=IconList[icon]);
    document.getElementById("themeSwitch").parentNode.style.color=color;
    if(utterancesLoad==1){utterancesTheme(utheme);}
}
function modeSwitch(){
    let currentMode=document.documentElement.getAttribute('data-color-mode');
    let newMode = currentMode === "light" ? "dark" : currentMode === "dark" ? "auto" : "light";
    localStorage.setItem("meek_theme", newMode);
    if(themeSettings[newMode]){
        changeTheme(...themeSettings[newMode]);
    }
}
function utterancesTheme(theme){
    const message={type:'set-theme',theme: theme};
    const iframe=document.getElementsByClassName('utterances-frame')[0];
    iframe.contentWindow.postMessage(message,'https://utteranc.es');
}
if(themeSettings[theme]){changeTheme(...themeSettings[theme]);}
console.log("\n %c Gmeek last https://github.com/Meekdai/Gmeek \n","padding:5px 0;background:#02d81d;color:#fff");
</script>

<script>
document.getElementById("pathHome").setAttribute("d",IconList["home"]);
document.getElementById("pathIssue").setAttribute("d",IconList["github"]);



function openComments(){
    cm=document.getElementById("comments");
    cmButton=document.getElementById("cmButton");
    cmButton.innerHTML="loading";
    span=document.createElement("span");
    span.setAttribute("class","AnimatedEllipsis");
    cmButton.appendChild(span);

    script=document.createElement("script");
    script.setAttribute("src","https://utteranc.es/client.js");
    script.setAttribute("repo","waibibab-cs/waibibab-cs.github.io");
    script.setAttribute("issue-term","title");
    
    if(localStorage.getItem("meek_theme")=="dark"){script.setAttribute("theme","dark-blue");}
    else if(localStorage.getItem("meek_theme")=="light") {script.setAttribute("theme","github-light");}
    else{script.setAttribute("theme","preferred-color-scheme");}
    
    script.setAttribute("crossorigin","anonymous");
    script.setAttribute("async","");
    cm.appendChild(script);

    int=self.setInterval("iFrameLoading()",200);
}

function iFrameLoading(){
    var utterances=document.getElementsByClassName('utterances');
    if(utterances.length==1){
        if(utterances[0].style.height!=""){
            utterancesLoad=1;
            int=window.clearInterval(int);
            document.getElementById("cmButton").style.display="none";
            console.log("utterances Load OK");
        }
    }
}

document.addEventListener('DOMContentLoaded', () => {
    const createClipboardHTML = (codeContent, additionalClasses = '') => `
        <pre class="notranslate"><code class="notranslate">${codeContent}</code></pre>
        <div class="clipboard-container position-absolute right-0 top-0 ${additionalClasses}">
            <clipboard-copy class="ClipboardButton btn m-2 p-0" role="button" style="display: inherit;">
                <svg height="16" width="16" class="octicon octicon-copy m-2"><path d="${IconList["copy"]}"></path></svg>
                <svg height="16" width="16" class="octicon octicon-check color-fg-success m-2 d-none"><path d="${IconList["check"]}"></path></svg>
            </clipboard-copy>
            <div class="copy-feedback">Copied!</div>
        </div>
    `;

    const handleCodeElements = (selector = '') => {
        document.querySelectorAll(selector).forEach(codeElement => {
            const codeContent = codeElement.innerHTML;
            const newStructure = document.createElement('div');
            newStructure.className = 'snippet-clipboard-content position-relative overflow-auto';
            newStructure.innerHTML = createClipboardHTML(codeContent);

            const parentElement = codeElement.parentElement;
            if (selector.includes('highlight')) {
                parentElement.insertBefore(newStructure, codeElement.nextSibling);
                parentElement.removeChild(codeElement);
            } else {
                parentElement.parentElement.replaceChild(newStructure, parentElement);
            }
        });
    };

    handleCodeElements('pre.notranslate > code.notranslate');
    handleCodeElements('div.highlight > pre.notranslate');

    let currentFeedback = null;
    document.querySelectorAll('clipboard-copy').forEach(copyButton => {
        copyButton.addEventListener('click', () => {
            const codeContent = copyButton.closest('.snippet-clipboard-content').innerText;
            const tempTextArea = document.createElement('textarea');
            tempTextArea.value = codeContent;
            document.body.appendChild(tempTextArea);
            tempTextArea.select();
            document.execCommand('copy');
            document.body.removeChild(tempTextArea);

            const copyIcon = copyButton.querySelector('.octicon-copy');
            const checkIcon = copyButton.querySelector('.octicon-check');
            const copyFeedback = copyButton.nextElementSibling;

            if (currentFeedback && currentFeedback !== copyFeedback) {currentFeedback.style.display = 'none';}
            currentFeedback = copyFeedback;

            copyIcon.classList.add('d-none');
            checkIcon.classList.remove('d-none');
            copyFeedback.style.display = 'block';
            copyButton.style.borderColor = 'var(--color-success-fg)';

            setTimeout(() => {
                copyIcon.classList.remove('d-none');
                checkIcon.classList.add('d-none');
                copyFeedback.style.display = 'none';
                copyButton.style.borderColor = '';
            }, 2000);
        });
    });
});

</script>


</html>
